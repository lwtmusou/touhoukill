sgs.ai_skill_invoke.xiangqi = function(self,data)	local from=self.player:getTag("xiangqi_from"):toPlayer()	local to =self.player:getTag("xiangqi_to"):toPlayer()	local damCard=self.player:getTag("xiangqi_card"):toCard()	if not from or not to then return false end	if not damCard then return false end	if self.player:objectName()==to:objectName() then		if not self:isFriend(from) then			return true		else			return self:getOverflow(from) >3		end 	end	if damCard:isKindOf("BasicCard") then		if self:isEnemy(to) then			return true		end		if self:isFriend(to) then			return  from:getHandcardNum()>=4 		end	end	if damCard:isKindOf("TrickCard") then		if self:isFriend(to) then			return true		end	end	return falseendsgs.ai_skill_cardchosen.xiangqi = function(self, who, flags)	local from=self.player:getTag("xiangqi_from"):toPlayer()	local to =self.player:getTag("xiangqi_to"):toPlayer()	local same =false 	local damCard=self.player:getTag("xiangqi_card"):toCard()		if  self:isEnemy(to) then		same=true	end	if flags == "h" then		local cards = from:getHandcards()		cards = sgs.QList2Table(cards)				if self.player:hasSkill("duxin") then			local card 			self:sortByUseValue(cards, same)			local keyword			if  damCard:isKindOf("BasicCard") then				keyword="BasicCard"			else				keyword="TrickCard"			end			for _,c in pairs (cards)do 				if same then						if c:isKindOf(keyword) then						card=c						break					end				else					if not c:isKindOf(keyword) then						card=c						break					end				end			end			if card then				return card			else				return cards[1]			end		end		local j = math.random(1, #cards)		return cards[j]	endendsgs.ai_skill_invoke.huzhu = function(self,data)	cards =self.player:getCards("h")	cardname="Jink"	for _,card in sgs.qlist(cards) do		if card:isKindOf(cardname) then			return false		end	end	if self:isWeak(self.player) then		return true	else		self:sort(self.friends_noself)		for _,p in pairs (self.friends_noself) do			if not self:isWeak(p) then				return true			end		end	end	return falseendsgs.ai_skill_invoke.huzhu_change = function(self,data)	local lord=self.room:getTag("huzhu_target"):toPlayer()	local jinks={}	if not self:isFriend(lord) then return false end	for _,card in sgs.qlist(self.player:getCards("h")) do		if card:isKindOf("Jink") then			table.insert(jinks,card)		end	end	if #jinks <2 then 		if self:isWeak(lord) then			return true		else			return false		end	end	if #jinks >1 then return true endendsgs.ai_choicemade_filter.skillInvoke.huzhu_change = function(self, player, promptlist)	local target=self.room:getTag("huzhu_target"):toPlayer()	if target then		if promptlist[#promptlist] == "yes" then			sgs.updateIntention(player, target, -60)		end	endendlocal maihuo_skill = {}maihuo_skill.name = "maihuo"table.insert(sgs.ai_skills, maihuo_skill)function maihuo_skill.getTurnUseCard(self)    if self.player:hasUsed("maihuoCard") then return nil end    local handcards = sgs.QList2Table(self.player:getHandcards())    if #handcards==0 then return nil end	self:sortByUseValue(handcards)	local reds={}	for _,c in pairs (handcards) do		if c:isRed() then			table.insert(reds,c)		end	end	if #reds>0 then		return sgs.Card_Parse("@maihuoCard=" .. reds[1]:getEffectiveId())	else		return sgs.Card_Parse("@maihuoCard=" .. handcards[1]:getEffectiveId())	endendsgs.ai_skill_use_func.maihuoCard = function(card, use, self)--sgs.ai_skill_use_func["#maihuo"] = function(card, use, self)        --[[self:sort(self.friends_noself,"handcard")		if #self.friends_noself >0 then			use.card = card            p =self.friends_noself[1]			if self:touhouHandCardsFix(p) and #self.friends_noself >1 then				p =self.friends_noself[2]			end			if use.to then				use.to:append(p)				if use.to:length() >= 1 then return end			end        end]]		local target =self:touhouFindPlayerToDraw(false, 2)		if not target and #self.friends_noself>0 then			target= self.friends_noself[1] 		end		if target then 			use.card = card			if use.to then				use.to:append(target)				if use.to:length() >= 1 then return end			end		endendsgs.maihuo_suit_value = {	heart=3.9,	diamond = 3.9}sgs.ai_use_value.maihuoCard = 7sgs.ai_use_priority.maihuoCard = 7sgs.ai_card_intention.maihuoCard = -70function SmartAI:getDamageSource(attacker)	if not attacker or attacker:hasSkill("wunian")  then		return false	end	return trueendsgs.ai_skill_use["@@yaoban"] = function(self, prompt)	if self.player:isKongcheng() then return "." end	local damage=self.player:getTag("yaoban_damage"):toDamage()	local to=damage.to	local targets={}    for _, p in ipairs(self.enemies) do        if to:objectName()~=p:objectName() then			local fakeDamage=sgs.DamageStruct()			fakeDamage.card=nil			fakeDamage.nature= sgs.DamageStruct_Normal			fakeDamage.damage=1			fakeDamage.from=self.player			fakeDamage.to=p			local yaoban_effect = self:touhouNeedAvoidAttack(fakeDamage, self.player, p)			--local yaoban_effect= self:touhouDamage(fakeDamage,self.player,p).damage>0			if not  yaoban_effect then continue end			table.insert(targets,p)		end    end		 	if #targets ==0 then return "."	 end	self:sort(targets,"hp")	local cards = self.player:getHandcards()	cards = sgs.QList2Table(cards)	self:sortByKeepValue(cards)	--return "#yaoban:" ..cards[1]:getEffectiveId().. ":->" .. targets[1]:objectName()	return "@yaobanCard=" ..cards[1]:getEffectiveId().. "->" .. targets[1]:objectName()endsgs.ai_card_intention.yaobanCard = 60sgs.ai_slash_prohibit.yaoban = function(self, from, to, card)	local fakeDamage=sgs.DamageStruct()	fakeDamage.card=nil	fakeDamage.nature= sgs.DamageStruct_Normal 	fakeDamage.damage=1	fakeDamage.from=to		if self:isEnemy(from,to) then 		if to:hasSkill("yaoban") and to:hasSkill("here") and not self:isWeak(to) and not to:isKongcheng() then			for _,friend in ipairs(self:getFriends(from)) do				fakeDamage.to=friend				if friend:getHp()<2 and self:touhouDamageInflicted(fakeDamage,to,friend).damage>0 then					return true				end			end		end	end	return falseendfunction SmartAI:copyHereSlash(card)	if not card:isKindOf("Slash") then		return card	end	if card:isKindOf("FireSlash")then		return card	end	local new_slash = sgs.cloneCard("fire_slash",card:getSuit(), card:getNumber())	if (card:getSubcards():length()>0) then		new_slash:addSubcards(card:getSubcards())	else		local id = card:getEffectiveId()		if (id>-1) then			new_slash:addSubcard(id)		end	end    if (card:getSkillName()) then		new_slash:setSkillName(card:getSkillName())	end	for _,flag in pairs(card:getFlags()) do		new_slash:setFlags(flag)	end	return new_slashendsgs.ai_skill_invoke.yuanling = function(self,data)	local target=self.player:getTag("yuanling"):toPlayer()	if self:isEnemy(target) then		return true	endendfunction Cansave(self,dying,need_peachs)	local all =self.room:getAlivePlayers()	local peach_asked=true	self.room:sortByActionOrder(all)	local peachs=0	for _,p in sgs.qlist(all) do		if peach_asked and p:objectName() ==self.player:objectName() then			peach_asked=false		end		if peach_asked then			continue		end		if self:isFriend(p,dying) then			peachs=peachs+ getCardsNum("Peach", p, self.player) 			if p:objectName() ==dying:objectName() then				peachs=peachs+ getCardsNum("Analeptic", p, self.player) 			end		end	end		return peachs +1 >= need_peachsendsgs.ai_skill_cardask["@songzang"] = function(self,data)	local dying = data:toDying()	local source = self:findRealKiller(dying.who, dying.damage) 	local executor = self:executorRewardOrPunish(dying.who, dying.damage) 	--[[if dying.damage and dying.damage.from then		source  = dying.damage.from	end]]	local self_role = self.player:getRole()	local target=self.room:getCurrentDyingPlayer()	local target_role=sgs.ai_role[target:objectName()]	local need_kill=false	local need_peachs = math.abs(1-target:getHp())	--[[if self.room:getLord():hasLordSkill("tymhwuyu") then		source = self.room:getLord()	end]]	if self_role== "loyalist" or self_role =="lord" then		if self:isEnemy(target)  then			if self:getOverflow()>0 then				need_kill=true			else				local can_save= Cansave(self,target,need_peachs)				if can_save then					need_kill=true				elseif target_role=="rebel"  then					if source and  self:isFriend(source) then					else						need_kill=true					end				end			end		end	end	if self_role== "renegade" then		local can_save=Cansave(self,target,need_peachs)		if self:isEnemy(target) then			if self:getOverflow()>0 and not (target:isLord() and self.room:alivePlayerCount()>2) then				need_kill=true			end			if can_save then				need_kill=true			elseif target_role=="rebel" then				if source and source:hasLordSkill("tymhwuyu") then				else					need_kill=true				end			end		else			if can_save then			elseif target_role=="rebel" then				if source and source:hasLordSkill("tymhwuyu") then				else					need_kill=true				end			end		end	end	if self_role== "rebel" then		if self:isFriend(target) 		and source and not self:isFriend(source) 		and not source:hasLordSkill("tymhwuyu") then			local card_str = self:willUsePeachTo(target)			if card_str =="." then				need_kill=true			end		end		if self:isEnemy(target) then			if self:getOverflow()>0 then				need_kill=true			elseif target:isLord() then				need_kill=true			else				need_kill = Cansave(self,target,need_peachs)			end		end	end		if not need_kill  then return "." end		local cards ={}	for _,card in sgs.qlist(self.player:getCards("he")) do		if card:getSuit()==sgs.Card_Spade then			table.insert(cards,card)		end	end	if #cards==0 then return "." end	self:sortByKeepValue(cards)    return "$" .. cards[1]:getId()endsgs.songzang_suit_value = {	spade = 4.9}sgs.ai_cardneed.songzang = function(to, card, self)	return  card:getSuit()==sgs.Card_Spadeendsgs.ai_skill_choice.cuiji=function(self)	if self:isWeak(self.player) then		return "red"	else		return "black"	end	endlocal baigui_skill = {}baigui_skill.name = "baigui"table.insert(sgs.ai_skills, baigui_skill)baigui_skill.getTurnUseCard = function(self, inclusive)        local cards = self.player:getCards("h")				cards=self:touhouAppendExpandPileToList(self.player,cards)        cards = sgs.QList2Table(cards)        self:sortByUseValue(cards, true)        		local can_use=false		local weak_targets1=0		local weak_targets2=0        targets1=self:getEnemies(self.player)		targets2=self:getFriends(self.player)		if #targets1 >= #targets2+1 then			can_use=true		end		for _,target in pairs(targets1) do			if self:isWeak(target) then				weak_targets1=weak_targets1+1			end		end		for _,target in pairs(targets2) do			if self:isWeak(target) then				weak_targets2=weak_targets2+1			end		end		if weak_targets1>weak_targets2 then			can_use=true		end				if not can_use then return false end		local spade_card		for _, card in ipairs(cards) do                if  card:getSuit()==sgs.Card_Spade and  not isCard("Peach", card, self.player) and not isCard("ExNihilo", card, self.player) then                        spade_card = card                        break                end        end        if spade_card then                local suit = spade_card:getSuitString()                local number = spade_card:getNumberString()                local card_id = spade_card:getEffectiveId()                local trick_str = ("savage_assault:baigui[%s:%s]=%d"):format(suit, number, card_id)                local trick = sgs.Card_Parse(trick_str)                                assert(trick)                return trick        endendsgs.baigui_suit_value = {	spade = 3.9}sgs.ai_use_value.baigui = sgs.ai_use_value.SavageAssault sgs.ai_use_priority.baigui = sgs.ai_use_priority.SavageAssault sgs.ai_cardneed.baigui = function(to, card, self)	return  card:getSuit()==sgs.Card_Spadeendsgs.ai_view_as.jiuchong = function(card, player, card_place)	local suit = card:getSuitString()	local number = card:getNumberString()	local card_id = card:getEffectiveId()	if card:getSuit()==sgs.Card_Heart and card_place == sgs.Player_PlaceHand then 		return ("analeptic:jiuchong[%s:%s]=%d"):format(suit, number, card_id)	endendlocal jiuchong_skill = {}jiuchong_skill.name = "jiuchong"table.insert(sgs.ai_skills, jiuchong_skill)jiuchong_skill.getTurnUseCard = function(self, inclusive)        local cards = self.player:getCards("h")		cards=self:touhouAppendExpandPileToList(self.player,cards)        cards = sgs.QList2Table(cards)        self:sortByUseValue(cards, true)                local heart_card        for _, card in ipairs(cards) do                if  card:getSuit()==sgs.Card_Heart and  not isCard("Peach", card, self.player) and not isCard("ExNihilo", card, self.player)                       and (self:getUseValue(card) < sgs.ai_use_value.Analeptic or inclusive or sgs.Sanguosha:correctCardTarget(sgs.TargetModSkill_Residue, self.player, sgs.cloneCard("slash")) > 0) then                        heart_card = card                        break                end        end        if heart_card then                local suit = heart_card:getSuitString()                local number = heart_card:getNumberString()                local card_id = heart_card:getEffectiveId()                local analeptic_str = ("analeptic:jiuchong[%s:%s]=%d"):format(suit, number, card_id)                local analeptic = sgs.Card_Parse(analeptic_str)                                assert(analeptic)                return analeptic        endendsgs.jiuchong_suit_value = {	heart = 3.9}sgs.ai_cardneed.jiuchong = function(to, card, self)	return  card:getSuit()==sgs.Card_Heartendsgs.ai_skill_invoke.guaili =function(self,data)	local target =self.player:getTag("guaili_target"):toPlayer()	if self:isEnemy(target) then		return true	else		return false	endendsgs.ai_skill_cardask["@guaili"] = function(self, data)	local use = data:toCardUse()	local need_hit=false	if self.player:getHandcardNum()==0 then return "." end	for _,p in sgs.qlist(use.to) do		if self:isEnemy(p) and (not p:isKongcheng()) then			if getCardsNum("Jink", p, self.player) < 1 or sgs.card_lack[p:objectName()]["Jink"] >0 then				continue			end			if  self:isWeak(p) then				need_hit=true			else 				if self.player:getHandcardNum()>1 then					need_hit= true				end			end		end	end		if need_hit then		local handcards = sgs.QList2Table(self.player:getHandcards())		self:sortByKeepValue(handcards)			return "$" .. handcards[#handcards]:getId()	end	return "."endsgs.guaili_suit_value = {	heart = 3.9,	diamond = 3.9}sgs.guaili_keep_value = {	Slash = 7}sgs.ai_cardneed.guaili = function(to, card, self)	if not self:willSkipPlayPhase(to) then		return card:isKindOf("Slash") and card:isRed()	endendsgs.ai_cardneed.haoyin = function(to, card, self)	return  card:isKindOf("Analeptic")endlocal jidu_skill = {}jidu_skill.name = "jidu"table.insert(sgs.ai_skills, jidu_skill)jidu_skill.getTurnUseCard = function(self, inclusive)        local cards = self.player:getCards("h")		cards=self:touhouAppendExpandPileToList(self.player,cards)        cards = sgs.QList2Table(cards)        if #cards==0 then return false end		self:sortByKeepValue(cards)		local spade_card=cards[1]        if spade_card then                local suit = spade_card:getSuitString()                local number = spade_card:getNumberString()                local card_id = spade_card:getEffectiveId()                local trick_str = ("duel:jidu[%s:%s]=%d"):format(suit, number, card_id)                local trick = sgs.Card_Parse(trick_str)                                assert(trick)                return trick        endendsgs.ai_skill_invoke.jidu =truesgs.ai_skill_choice.gelong= function(self)	local num=self.player:getHandcardNum()-self.player:getMaxCards()	if self:touhouHpLocked(self.player) then		return "gelong1"	end	local card = sgs.cloneCard("supply_shortage")	local source=self.room:findPlayerBySkillName("gelong")	if self:touhouDelayTrickBadTarget(card, self.player, source) then		return "gelong2"	end	if num>=1 or self.player:getHp()<2 then		return "gelong2"	else		return "gelong1"	endend--sgs.ai_skill_invoke.chuanran =true--[[sgs.ai_skill_use["@@chuanran"] = function(self, prompt)	local id=self.player:getTag("chuanran_id"):toInt()	local cards={}	for _,c in sgs.qlist(self.player:getCards("he")) do		if c:isBlack() then			table.insert(cards,c)		end	end		if #cards==0 then return "." end		local card=sgs.Sanguosha:getCard(id)	local real_delay=true	if not card:isKindOf("DelayedTrick") then		card= sgs.cloneCard("supply_shortage")		card:addSubcard(id)		real_delay=false	end	local current=self.room:getCurrent()	others=self.room:getOtherPlayers(current)	self.room:sortByActionOrder(others)	local target	for _,p in sgs.qlist(others) do		if self:isEnemy(p) and not p:containsTrick(card:objectName()) and not self:touhouDelayTrickBadTarget(card, p,self.player)then			if self:playerGetRound(p) > self:playerGetRound(self.player) then--山女先行动				if card:isKindOf("Indulgence") then					break				elseif card:isKindOf("SupplyShortage") then					if not real_delay then						target=p						break					else						if  self.player:distanceTo(p) ==1 and not self.player:isProhibited(p, card) then							break						else							target=p							break						end					end				end			else				target=p				break			end		end	end	if target then		self:sortByKeepValue(cards,true)		 return "@chuanranCard="..cards[1]:getEffectiveId().."->"..target:objectName()	end	return "." end]]sgs.ai_skill_use["@@chuanran"] = function(self, prompt)	local id=self.player:getTag("chuanran_id"):toInt()	local cards={}	for _,c in sgs.qlist(self.player:getCards("he")) do		if c:isBlack() then			table.insert(cards,c)		end	end		if #cards==0 then return "." end		local card=sgs.Sanguosha:getCard(id)	local real_delay=true	if not card:isKindOf("DelayedTrick") then		card= sgs.cloneCard("supply_shortage")		card:addSubcard(id)		real_delay=false	end	local current=self.room:getCurrent()	others=self.room:getOtherPlayers(current)	self.room:sortByActionOrder(others)	local target	for _,p in sgs.qlist(others) do		if self:isEnemy(p) and not p:containsTrick(card:objectName()) and not self:touhouDelayTrickBadTarget(card, p,self.player)then			--[[if self:playerGetRound(p) > self:playerGetRound(self.player) then--山女先行动				if card:isKindOf("Indulgence") then					break				elseif card:isKindOf("SupplyShortage") then					if not real_delay then						target=p						break					else						if  self.player:distanceTo(p) ==1 and not self.player:isProhibited(p, card) then							break						else							target=p							break						end					end				end			else]]				target=p				break			--end		end	end	if target then		self:sortByKeepValue(cards,true)		 return "@chuanranCard="..cards[1]:getEffectiveId().."->"..target:objectName()	end	return "." endsgs.chuanran_suit_value = {	spade = 3.9,	club = 3.9}sgs.ai_cardneed.chuanran = function(to, card, self)	return  card:isBlack()endsgs.ai_card_intention.chuanranCard=40sgs.ai_skill_playerchosen.rebing = function(self, targets)	local target_table =sgs.QList2Table(targets)	self:sort(target_table, "handcard")	for _,p in pairs (target_table) do		if self:isEnemy(p) then			return p		end	end	return nilendsgs.ai_playerchosen_intention.rebing = 30 sgs.ai_skill_invoke.diaoping  =function(self,data)	if self.player:isKongcheng() then return false end	local use=self.player:getTag("diaoping_slash"):toCardUse()	if use.from then		if self:isFriend(use.from) then return false end		for _,p in sgs.qlist(use.to) do			if self:isFriend(p) then				if self:isWeak(p) then					return true				else					if self.player:getHandcardNum()>=2 then 						return true					end				end			end		end	end	return falseendsgs.ai_cardneed.diaoping = function(to, card, self)	if not self:willSkipPlayPhase(to) then		return  (not to:getWeapon() and  getCardsNum("Weapon",to,self.player)<1 and card:isKindOf("Weapon"))		or (not to:getOffensiveHorse() and  getCardsNum("OffensiveHorse",to,self.player)<1 and card:isKindOf("OffensiveHorse"))		or card:getNumber()>10	endendfunction SmartAI:slashProhibitToDiaopingTarget(card,from,enemy)	local diaopingEffect, kisume  = self:hasDiaopingEffect(from,enemy)	if kisume then 		local from_card = self:getMaxCard(from) 		local kisume_card = self:getMaxCard(kisume)  		if not from_card then  return true end		local from_point = from_card:getNumber()		local kisume_point = 6		if kisume_card then 			kisume_point = kisume_card:getNumber()		end		local handcardnum = kisume:getHandcardNum()		for i =1, handcardnum, 1 do			kisume_point = kisume_point + handcardnum/2		end		kisume_point = math.min(kisume_point,14)		return from_point < kisume_point	end	return falseendfunction SmartAI:hasDiaopingEffect(from,target)	local kisume  = self.room:findPlayerBySkillName("diaoping")	if kisume and not kisume:isKongcheng() 	and kisume:inMyAttackRange(target) and not self:isEnemy(kisume, target) 	and from:getHandcardNum()>=2 and from:faceUp() then		return true ,kisume 	end	return false, nilend--嘲讽值设定--[[sgs.ai_chaofeng.dld001 = 2sgs.ai_chaofeng.dld002 = 2sgs.ai_chaofeng.dld003 = 0sgs.ai_chaofeng.dld004 = -1sgs.ai_chaofeng.dld005 = 2sgs.ai_chaofeng.dld006 = 1sgs.ai_chaofeng.dld007 = -2sgs.ai_chaofeng.dld008 = 1sgs.ai_chaofeng.dld009 = -1]]